---
title: 搭建 Dubbo 开发环境
description: 基于 SpringBoot 搭建 Dubbo 直连式开发环境 
date: false
lastUpdated: false
tag:
- Dubbo
---

# 快速上手

## 一、概述

在 RPC 开发过程之中，主要涉及到三个模块：API，Consumer，Provider。

其中 API 作为 Consumer 和 Provider 交互的一个标准，其实就是一组接口定义，让其余模块知道应该提供那些接口能力，具备那些接口能力。

在一个 Dubbo 应用之中，主要包含如下内容：

![image-20241218225258991](asserts/image-20241218225258991.png)

> 其中，注册中心，实际上是可以选择的，非必须的

如果不需要注册中心，Consumer 直接访问 Provider 通信。这种方式也被称之为，直连式。接下来，我们首先搭建一个直连式的Dubbo应用。

## 二、Hello World

### 2.1 依赖管理

定义一个父项目，进行依赖的统一管理

> 如果涉及到多个项目统一管理，我们可以采用 flatten 插件来进行统一的版本号管理

```xml
<properties>
    <revision>1.0.0-SNAPSHOT</revision>
    <spring.boot.version>2.7.18</spring.boot.version>
    <dubbo.version>3.2.0</dubbo.version>
    <flatten-maven-plugin.version>1.6.0</flatten-maven-plugin.version>
    <lombok.version>1.18.34</lombok.version>
    <maven-compiler-plugin.version>3.13.0</maven-compiler-plugin.version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring.boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>

        <dependency>
            <groupId>org.apache.dubbo</groupId>
            <artifactId>dubbo-bom</artifactId>
            <version>${dubbo.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### 2.2 API 模块
我们前面已经提供了，API 模块主要作为接口定义。我们定义一个简单的接口：

```java
public interface UserService {
    /**
     * 通过用户名获取用的信息
     * @param userId 请求信息
     * @return 用户信息
     */
    UserInfoRespDTO getUserNameByUserID(Integer userId);

    /**
     * 通过用户信息获取用户ID
     * @param userInfoReqDTO 用户信息
     * @return 用户信息
     */
    UserInfoRespDTO register(UserInfoReqDTO userInfoReqDTO);
}
```

对于RPC 调用过程之中的实体类对象，必须实现序列化接口。两个对象的定义如下：

- UserInfoReqDTO

```java
@Data
public class UserInfoReqDTO implements Serializable {
    /**
     * 用户名
     */
    private String username;

    /**
     * 用户密码
     */
    private String password;
}
```

- UserInfoRespDTO

```java
@Data
public class UserInfoRespDTO implements Serializable {

    /**
     * 用户编号
     */
    private Integer userId;

    /**
     * 用户名
     */
    private String username;

    /**
     * 用户性别
     */
    private String sex;
}
```

在定义完成 API 模块之中，接下来，我们就分别基于 **XML** 和 **SpringBoot** 来进行第一个 Dubbo 应用的开发。

开发完成之中，我们首先将 API 模块依赖，添加到 父项目之中

```xml
<dependency>
    <groupId>com.coding</groupId>
    <artifactId>dubbo-api</artifactId>
    <version>${revision}</version>
</dependency>
```

这里我也将 API 模块对应的 xml 配置文件

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.coding</groupId>
        <artifactId>Study-Dubbo3</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>dubbo-api</artifactId>
    <packaging>jar</packaging>

    <name>dubbo-api</name>

    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
</project>
```

### 2.3 Provider

首先，我们来开发 Provider 模块。在 Provider 模块，我们首先添加如下的依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>com.coding</groupId>
        <artifactId>dubbo-api</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.apache.dubbo</groupId>
        <artifactId>dubbo-spring-boot-starter</artifactId>
    </dependency>
</dependencies>
```

实现 API 模块的接口，完成功能的开发。**请注意，这里 `@DubboService` 注解**

```java
@DubboService
@Service
@Slf4j
public class UserServiceImpl implements UserService {
    /**
     * 通过用户名获取用的信息
     * @param userId 请求信息
     * @return 用户信息
     */
    public UserInfoRespDTO getUserNameByUserID(Integer userId) {
        log.info("接受到的用户ID为：{}", userId);
        return buildDefaultUserInfo();
    }
    /**
     * 通过用户信息获取用户ID
     * @param userInfoReqDTO 用户信息
     * @return 用户信息
     */
    @Override
    public UserInfoRespDTO register(UserInfoReqDTO userInfoReqDTO) {
        log.info("接受到用户的注册请求，请求参数为：{}", userInfoReqDTO);
        return buildDefaultUserInfo();
    }
    
    private UserInfoRespDTO buildDefaultUserInfo() {
        UserInfoRespDTO userInfoRespDTO = new UserInfoRespDTO();
        userInfoRespDTO.setUserId((int) System.currentTimeMillis());
        userInfoRespDTO.setUsername("coding");
        userInfoRespDTO.setSex("男");
        return userInfoRespDTO;
    }
}
```

开发完成之后，在 SpringBoot 启动类中，添加：`@EnableDubbo` 注解

```java
@SpringBootApplication
@EnableDubbo
public class DubboProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(DubboProviderApplication.class, args);
    }
}
```

接下来，在配置文件之中如下的配置：

```yaml
server:
  port: 9001
  servlet:
    context-path: /provider
spring:
  application:
    name: dubbo-provider
dubbo:
  application:
    name: ${spring.application.name}
```

在启动完成之中，我们可以看一下控制台输出的信息，其中有两块内容比较重要：

- 向外暴露的访问的 URL

```markdown
Export dubbo service com.coding.api.UserService to url dubbo://192.168.1.9:20880/com.coding.api.UserService?anyhost=true&application=dubbo-provider&background=false&bind.ip=192.168.1.9&bind.port=20880&deprecated=false&dubbo=2.0.2&dynamic=true&executor-management-mode=isolation&file-cache=true&generic=false&interface=com.coding.api.UserService&ipv6=2408:8207:484d:d3a0:4865:f67c:ae63:eba7&methods=getUserNameByUserID,register&pid=13240&prefer.serialization=fastjson2,hessian2&qos.enable=true&release=3.2.0&side=provider&timestamp=1734525067748, dubbo version: 3.2.0, current host: 192.168.1.9
```

- 元数据信息

```markdown
The MetadataService exports urls : 
[dubbo://192.168.1.9:20881/org.apache.dubbo.metadata.MetadataService?anyhost=true&application=dubbo-provider&background=false&bind.ip=192.168.1.9&bind.port=20881&delay=0&deprecated=false&dubbo=2.0.2&dynamic=true&executor-management-mode=isolation&file-cache=true&generic=false&getAndListenInstanceMetadata.1.callback=true&getAndListenInstanceMetadata.return=true&getAndListenInstanceMetadata.sent=true&group=dubbo-provider&interface=org.apache.dubbo.metadata.MetadataService&ipv6=2408:8207:484d:d3a0:4865:f67c:ae63:eba7&methods=exportInstanceMetadata,getAndListenInstanceMetadata,getExportedServiceURLs,getExportedURLs,getExportedURLs,getExportedURLs,getExportedURLs,getExportedURLs,getInstanceMetadataChangedListenerMap,getMetadataInfo,getMetadataInfos,getMetadataURL,getServiceDefinition,getServiceDefinition,getSubscribedURLs,isMetadataService,serviceName,toSortedStrings,toSortedStrings,version&pid=13240&prefer.serialization=fastjson2,hessian2&qos.enable=true&register=false&release=3.2.0&revision=3.2.0&side=provider&timestamp=1734525069503&version=1.0.0],
dubbo version: 3.2.0, current host: 192.168.1.9
```

从日志我们看到，这个是 MetadataService 要暴露出去的信息，至于这些信息是什么？我们在后面的章节之中进行说明

### 2.4 Consumer

在 consumer 模块，首先导入如下依赖：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.apache.dubbo</groupId>
        <artifactId>dubbo-spring-boot-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>com.coding</groupId>
        <artifactId>dubbo-api</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    
</dependencies>
```

添加如下配置：

```yaml
server:
  port: 8080
  servlet:
    context-path: /consumer
dubbo:
  application:
    name: dubbo-consumer
```

在 Consumer 模块，完成对于 Provider 模块的调用，这部分功能我们将通过单元测试的方式来进行演示

```java
@SpringBootTest(classes = DubboConsumerApplication.class)
@Slf4j
public class DubboConsumerTest {

    @DubboReference(url = "dubbo://192.168.1.9:20880/com.coding.api.UserService")
    private UserService userService;

    @Test
    public void testFirstApplication() {
        UserInfoRespDTO userNameByUserID = userService.getUserNameByUserID(1);
        Assert.notNull(userNameByUserID, "获取用户信息失败");
        log.info("获取到的用户信息为：{}", userNameByUserID);
    }
}
```

注意，这里的 url 参数就是 Provider 模块启动时，在控制台输出的内容，不过我们这里只使用到一部分。到这里，第一个 Dubbo 应用开发已经完成了。这种开发方式，也称之为**直连式**。

## 三、细节补充

接下来，我们对于上面程序的一些细节进行补充。

首先，我们在 Provider 模块之中，在启动类上，添加了 `@EnableDubbo` 的注解

这个注解的主要作用用于扫描 `@DubboService` 并将对应的对象实例，发布成为了 RPC 服务，而他的扫描路径，就是应用这种注解的类所在的包及其子包，当然了，我们也可以通过里面的属性，来指定扫描那个包。

```java
@EnableDubbo(scanBasePackages = "com.coding.provider")
```

在 Consumer 模块，我们注意到，Consumer 获取到的 UserService 对象，实际上是代理对象，所以，`@DubboReference` 的主要作用就是，注入远端服务的代理对象。所以我们实际的调用应该是下面这样

![](asserts/1723369392803-f2a0280d-c923-4411-ab99-c28f2ad82ad6.png)

加入了代理对象之后，Consumer 实际上和原来的调用没有区别，完全屏蔽了网络通信的整个过程。如果加入了注册中心，就变成下面这样了：

![image-20241218225642336](asserts/image-20241218225642336.png)